C
C     FFTE: A FAST FOURIER TRANSFORM PACKAGE
C
C     (C) COPYRIGHT SOFTWARE, 2000-2004, ALL RIGHTS RESERVED
C                BY
C         DAISUKE TAKAHASHI
C         GRADUATE SCHOOL OF SYSTEMS AND INFORMATION ENGINEERING
C         UNIVERSITY OF TSUKUBA
C         1-1-1 TENNODAI, TSUKUBA, IBARAKI 305-8573, JAPAN
C         E-MAIL: daisuke@cs.tsukuba.ac.jp
C
C
C     PARALLEL 1-D COMPLEX FFT ROUTINE (FOR VECTOR MACHINES)
C
C     FORTRAN77 + MPI SOURCE PROGRAM
C
C     CALL PZFFT1D(A,B,W,N,ICOMM,ME,NPU,IOPT)
C
C     W(N/NPU) IS SINE/COSINE TABLE (COMPLEX*16)
C     N IS THE LENGTH OF THE TRANSFORMS (INTEGER*8)
C       -----------------------------------
C         N = (2**IP) * (3**IQ) * (5**IR)
C       -----------------------------------
C     ICOMM IS THE COMMUNICATOR (INTEGER*4)
C     ME IS THE RANK (INTEGER*4)
C     NPU IS THE NUMBER OF PROCESSORS (INTEGER*4)
C     IOPT = 0 FOR INITIALIZING THE COEFFICIENTS (INTEGER*4)
C     IOPT = -1 FOR FORWARD TRANSFORM WHERE
C              A(N/NPU) IS COMPLEX INPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE A(BLOCK)
C              B(N/NPU) IS COMPLEX OUTPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE B(BLOCK)
C     IOPT = +1 FOR INVERSE TRANSFORM WHERE
C              A(N/NPU) IS COMPLEX INPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE A(BLOCK)
C              B(N/NPU) IS COMPLEX OUTPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE B(BLOCK)
C     IOPT = -2 FOR FORWARD TRANSFORM WHERE
C              A(N/NPU) IS COMPLEX INPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE A(BLOCK)
C              B(N/NPU) IS COMPLEX OUTPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE B(CYCLIC)
C     IOPT = +2 FOR INVERSE TRANSFORM WHERE
C              A(N/NPU) IS COMPLEX INPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE A(CYCLIC)
C              B(N/NPU) IS COMPLEX OUTPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE B(BLOCK)
C
C     WRITTEN BY DAISUKE TAKAHASHI
C
      SUBROUTINE PZFFT1D(A,B,W,N,ICOMM,ME,NPU,IOPT)
      IMPLICIT REAL*8 (A-H,O-Z)
      INCLUDE 'param.h'
      COMPLEX*16 A(*),B(*),W(*)
      COMPLEX*16 W1(NDA2/2+NP),W2(NDA2/2+NP)
      DIMENSION IP(3),IP1(3),IP2(3),LNPU(3)
      INTEGER*8 N,NN
      SAVE W1,W2
C
      NN=N/INT8(NPU)
      NN2=NN/NPU
      CALL FACTOR(NPU,LNPU)
      CALL FACTOR8(N,IP)
      DO 10 I=1,3
        IP1(I)=MAX0(LNPU(I),(IP(I)+1)/2)
        IP2(I)=IP(I)-IP1(I)
   10 CONTINUE
      N1=(2**IP1(1))*(3**IP1(2))*(5**IP1(3))
      N2=(2**IP2(1))*(3**IP2(2))*(5**IP2(3))
C
      IF (IOPT .EQ. 0) THEN
        CALL SETTBL(W1,N1)
        CALL SETTBL(W2,N2)
        CALL PSETTBL2(W,N1,N2,ME,NPU)
        RETURN
      END IF
C
      IF (IOPT .EQ. 1 .OR. IOPT .EQ. 2) THEN
        DO 20 I=1,NN
          A(I)=DCONJG(A(I))
   20   CONTINUE
      END IF
C
      IF (IOPT .EQ. -1 .OR. IOPT .EQ. 1 .OR. IOPT .EQ. -2) THEN
        CALL ZTRANS(A,B,NPU,NN2)
        CALL PZTRANS(B,A,NN,ICOMM,NPU)
      END IF
C
      CALL MFFT235A(A,B,W2,N1/NPU,N2,IP2)
      CALL MZMUL(A,W,NN)
      CALL ZTRANS(A,B,N1,N2/NPU)
      CALL PZTRANS(B,A,NN,ICOMM,NPU)
      CALL MZTRANSA(A,B,N2/NPU,N1/NPU,NPU)
      CALL MFFT235A(B,A,W1,N2/NPU,N1,IP1)
C
      IF (IOPT .EQ. -1 .OR. IOPT .EQ. 1 .OR. IOPT .EQ. 2) THEN
        CALL PZTRANS(B,A,NN,ICOMM,NPU)
        CALL ZTRANS(A,B,NN2,NPU)
      END IF
C
      IF (IOPT .EQ. 1 .OR. IOPT .EQ. 2) THEN
        DN=1.0D0/DBLE(N)
        DO 30 I=1,NN
          B(I)=DCONJG(B(I))*DN
   30   CONTINUE
      END IF
      RETURN
      END
      SUBROUTINE MZMUL(A,W,NN)
      IMPLICIT REAL*8 (A-H,O-Z)
      COMPLEX*16 A(*),W(*)
      INTEGER*8 NN
C
      DO 10 I=1,NN
        A(I)=A(I)*W(I)
   10 CONTINUE
      RETURN
      END
      SUBROUTINE PSETTBL2(W,N1,N2,ME,NPU)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION W(2,N1/NPU,*)
C
      PI2=8.0D0*DATAN(1.0D0)
      PX=-PI2/(DBLE(N1)*DBLE(N2))
      DO 20 K=1,N2
        DO 10 J=1,N1/NPU
          W(1,J,K)=DCOS(PX*(DBLE(ME)+DBLE(J-1)*DBLE(NPU))*DBLE(K-1))
          W(2,J,K)=DSIN(PX*(DBLE(ME)+DBLE(J-1)*DBLE(NPU))*DBLE(K-1))
   10   CONTINUE
   20 CONTINUE
      RETURN
      END
