C
C     FFTE: A FAST FOURIER TRANSFORM PACKAGE
C
C     (C) COPYRIGHT SOFTWARE, 2000-2004, 2008-2014, ALL RIGHTS RESERVED
C                BY
C         DAISUKE TAKAHASHI
C         FACULTY OF ENGINEERING, INFORMATION AND SYSTEMS
C         UNIVERSITY OF TSUKUBA
C         1-1-1 TENNODAI, TSUKUBA, IBARAKI 305-8573, JAPAN
C         E-MAIL: daisuke@cs.tsukuba.ac.jp
C
C
C     PARALLEL 2-D COMPLEX FFT ROUTINE (FOR NVIDIA GPUS)
C
C     CUDA FORTRAN + MPI SOURCE PROGRAM
C
C     CALL PZFFT2D(A,B,NX,NY,ICOMM,NPU,IOPT)
C
C     NX IS THE LENGTH OF THE TRANSFORMS IN THE X-DIRECTION (INTEGER*4)
C     NY IS THE LENGTH OF THE TRANSFORMS IN THE Y-DIRECTION (INTEGER*4)
C       ------------------------------------
C         NX = (2**IP) * (3**IQ) * (5**IR)
C         NY = (2**JP) * (3**JQ) * (5**JR)
C       ------------------------------------
C     ICOMM IS THE COMMUNICATOR (INTEGER*4)
C     NPU IS THE NUMBER OF PROCESSORS (INTEGER*4)
C     IOPT = 0 CREATE AN FFT PLAN (INTEGER*4)
C     IOPT = -1 FOR FORWARD TRANSFORM WHERE
C              A(NX,NY/NPU) IS COMPLEX INPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE A(*,BLOCK)
C              B(NX,NY/NPU) IS COMPLEX OUTPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE B(*,BLOCK)
C     IOPT = +1 FOR INVERSE TRANSFORM WHERE
C              A(NX,NY/NPU) IS COMPLEX INPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE A(*,BLOCK)
C              B(NX,NY/NPU) IS COMPLEX OUTPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE B(*,BLOCK)
C     IOPT = -2 FOR FORWARD TRANSFORM WHERE
C              A(NX,NY/NPU) IS COMPLEX INPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE A(*,BLOCK)
C              B(NX/NPU,NY) IS COMPLEX OUTPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE B(BLOCK,*)
C     IOPT = +2 FOR INVERSE TRANSFORM WHERE
C              A(NX/NPU,NY) IS COMPLEX INPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE A(BLOCK,*)
C              B(NX,NY/NPU) IS COMPLEX OUTPUT VECTOR (COMPLEX*16)
C!HPF$ DISTRIBUTE B(*,BLOCK)
C     IOPT = 3 DESTROY THE FFT PLAN
C
C     WRITTEN BY DAISUKE TAKAHASHI
C
      SUBROUTINE PZFFT2D(A,B,NX,NY,ICOMM,NPU,IOPT)
      use cudafor
      use cufft
      IMPLICIT REAL*8 (A-H,O-Z)
      COMPLEX*16 A(*),B(*)
      complex(8),device,allocatable :: A_d(:),B_d(:)
      INTEGER*4 PLANX,PLANY
      SAVE PLANX,PLANY
C
      NNX=NX/NPU
      NNY=NY/NPU
      NN=NX*NNY
C
      IF (IOPT .EQ. 0) THEN
        istat=cufftPlan1D(PLANX,NX,CUFFT_Z2Z,NNY)
        istat=cufftPlan1D(PLANY,NY,CUFFT_Z2Z,NNX)
        RETURN
      END IF
C
      IF (IOPT .EQ. 3) THEN
        istat=cufftDestroy(PLANX)
        istat=cufftDestroy(PLANY)
        RETURN
      END IF
C
      ALLOCATE(A_d(NN),B_d(NN))
      A_d=A(1:NN)
C
      IF (IOPT .EQ. 1 .OR. IOPT .EQ. 2) THEN
!$cuf kernel do <<<*,*>>>
        DO 10 I=1,NN
          A_d(I)=DCONJG(A_d(I))
   10   CONTINUE
      END IF
C
      IF (IOPT .EQ. -1 .OR. IOPT .EQ. -2) THEN
        CALL PZFFT2DF(A_d,B_d,NX,NY,ICOMM,NPU,IOPT,PLANX,PLANY)
      ELSE
        CALL PZFFT2DB(A_d,B_d,NX,NY,ICOMM,NPU,IOPT,PLANX,PLANY)
      END IF
C
      IF (IOPT .EQ. 1 .OR. IOPT .EQ. 2) THEN
        DN=1.0D0/(DBLE(NX)*DBLE(NY))
!$cuf kernel do <<<*,*>>>
        DO 20 I=1,NN
          B_d(I)=DCONJG(B_d(I))*DN
   20   CONTINUE
      END IF
C
      B(1:NN)=B_d
      DEALLOCATE(A_d,B_d)
      RETURN
      END
      SUBROUTINE PZFFT2DF(A_d,B_d,NX,NY,ICOMM,NPU,IOPT,PLANX,PLANY)
      use cudafor
      use cufft
      IMPLICIT REAL*8 (A-H,O-Z)
      INCLUDE 'mpif.h'
      complex(8),device :: A_d(*),B_d(*)
      INTEGER*4 PLANX,PLANY
C
      NNX=NX/NPU
      NNY=NY/NPU
      NN=NX*NNY
C
      istat=cufftExecZ2Z(PLANX,A_d,A_d,CUFFT_FORWARD)
      CALL ZTRANS(A_d,B_d,NX,NNY)
      CALL MPI_ALLTOALL(B_d,NN/NPU,MPI_DOUBLE_COMPLEX,A_d,NN/NPU,
     1                  MPI_DOUBLE_COMPLEX,ICOMM,IERR)
      CALL MZTRANS(A_d,B_d,NNY,NNX,NPU)
      istat=cufftExecZ2Z(PLANY,B_d,A_d,CUFFT_FORWARD)
      CALL ZTRANS(A_d,B_d,NY,NNX)
      IF (IOPT .EQ. -2) RETURN
      CALL MPI_ALLTOALL(B_d,NN/NPU,MPI_DOUBLE_COMPLEX,A_d,NN/NPU,
     1                  MPI_DOUBLE_COMPLEX,ICOMM,IERR)
      CALL MZTRANS(A_d,B_d,NNX,NNY,NPU)
      RETURN
      END
      SUBROUTINE PZFFT2DB(A_d,B_d,NX,NY,ICOMM,NPU,IOPT,PLANX,PLANY)
      use cudafor
      use cufft
      IMPLICIT REAL*8 (A-H,O-Z)
      INCLUDE 'mpif.h'
      complex(8),device :: A_d(*),B_d(*)
      INTEGER*4 PLANX,PLANY
C
      NNX=NX/NPU
      NNY=NY/NPU
      NN=NX*NNY
C
      IF (IOPT .EQ. 1) THEN
        CALL MZTRANS(A_d,B_d,NNX,NPU,NNY)
        CALL MPI_ALLTOALL(B_d,NN/NPU,MPI_DOUBLE_COMPLEX,A_d,NN/NPU,
     1                    MPI_DOUBLE_COMPLEX,ICOMM,IERR)
      END IF
C
      CALL ZTRANS(A_d,B_d,NNX,NY)
      istat=cufftExecZ2Z(PLANY,B_d,A_d,CUFFT_FORWARD)
      CALL MZTRANS(A_d,B_d,NNY,NPU,NNX)
      CALL MPI_ALLTOALL(B_d,NN/NPU,MPI_DOUBLE_COMPLEX,A_d,NN/NPU,
     1                  MPI_DOUBLE_COMPLEX,ICOMM,IERR)
      CALL ZTRANS(A_d,B_d,NNY,NX)
      istat=cufftExecZ2Z(PLANX,B_d,B_d,CUFFT_FORWARD)
      RETURN
      END
